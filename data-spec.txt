audio data:
	List of 1-byte samples, played at 18396Hz:
		0vvvxxxx
			Wave data value = vvv * xxxx

palette data:
	List of palettes, 8 bytes each.
	Palettes are referred to by their index into this list.
	This is called the *palette index* and is a 2-byte value.
	Each palette is a list of 4 colors.
	Each color is a 2-byte value:
		gggrrrrr 0bbbbbGG
	where red is rrrrr, blue is bbbbb, and green is GGggg.
	ie. it's like this but little-endian:
		0bbb bbgg gggr rrrr
	Values are not linear to brightness of each color.
	I'll try to get a proper color space mapping available later.

rom tile data:
	List of tiles, 16 bytes each.
	Tiles are referred to by their index into this list.
	This is called the *tile rom index* and is a 2-byte value.
	Tiles are as per normal gameboy tile format, ie:
		Each row of 8 pixels is defined by two bytes.
		The first byte defines the lower bits of the pixel values,
		and the second byte defines the upper bits.
		eg. 01010101 00110011 maps to pixel values 01230123

vram tile data:
	This is standard GB stuff. There are two banks of 256 tiles each.
	These tiles are indexed by both bank and index.
	These are known as *tile vram bank* and *tile vram index*
	and are 1-byte values each.
	The format is the same as rom tile data.

frame data:
	List of frames, 2048 bytes each.
	Frames are referred to by their index into this list.
	This is called the *frame index*.
	Each frame consists of:
		19 rows:
			Each row consists of 21 tile vram indexes
			followed by 21 tile flag values,
			corresponding to the tiles to display in this row.
			Tile flag are one byte:
				0vh0bppp
				where v and h are flags saying if the tile should be vertically or horizontally flipped,
				b is the tile vram bank of the tile to display,
				and ppp is the color palette number to use.
		144 palette changes:
			Before each line, 4 palettes are written.
			On even lines (0, 2, etc), palettes 0-3 are overwritten.
			On odd lines (1, 3, etc), palettes 4-7 are overwritten.
			Each palette change consists of 4 palette indexes, stored big-endian.
			For example, to change the 4 palettes to indexes 20, 256, 400 and 1,
			the values should be (in bytes):
				(0, 20), (1, 0), (1, 144), (0, 1)
		1 byte of scroll values:
			0yyy0xxx
			where yyy is scroll y value, and xxx is scroll x value.
			This allows you to scroll up to just under one tile in either axis, exposing the
			19th row or 21st column.
		One byte indicating length of the following load order list, between 0 and 19.
		List of load orders:
			A load order happens before the frame and indicates what tiles should be loaded into
			VRAM. It consists of two parts:
				The source index:
					The tile rom index of the first tile to copy.
				The destination bank:
					Either 0 or 1, the tile vram bank to load the tiles into
				The destination index:
					The tile vram index of the first index to copy into
				Length:
					How many tiles to copy. Up to 128.
			So, for example, if you wanted to copy tiles 5-19 from ROM into VRAM bank 0 indexes 30-44,
			and tiles 300-301 from ROM into VRAM bank 1 indexes 254-255, you would do this:
				2 (two load orders to do)
				0, 5 (first source starts at 5)
				0, 30 (dest bank 0, index starts at 30)
				15 (fifteen tiles to copy)
				1, 44 (second source starts at 300)
				1, 254 (dest bank 1, index starts at 254)
				2 (two tiles to copy)
			NOTE: Across all load orders, the total number of tiles written cannot be > 128.
		The remaining bytes up to 2048 are unused padding
			You can calculate how many bytes to use as: 96 - <number of load orders> * 5

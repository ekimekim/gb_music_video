NOTE: in all cases, when showing bits within a byte, the left-most bit is the most signifigant.
	For example, "x0000000" means 128 when x = 1, or 0 when x = 0.

NOTE: In all cases, when referring to an address within a bank of an object,
	the address is of the object when that bank is loaded,
	which is equal to $4000 + <address within bank>.
	For example, the second palette group in bank 5 is at position $0020 within the bank
	(because each palette group is 32 == $20 bytes long), so its address is $4020.

audio data:
	List of samples, played at 18396Hz.
	Samples are grouped into pairs:
		0vvv0VVV
		xxxxXXXX
	where vvv, xxxx is the first sample, and VVV, XXXX is the second.
	Wave data values = (vvv+1) * (xxxx - 7.5)

palette group data:
	List of palette groups, 32 bytes each.
	Palette groups are referred to by their address within each bank,
	called the *palette group address*, and their bank, called the *palette group bank*.
	A palette group is a list of 4 palettes which are used as a set,
	ie. you specify the entire palette group to be loaded into memory for a particular line.
	Each palette within the group is a list of 4 colors.
	Each color is a 2-byte value:
		gggrrrrr 0bbbbbGG
	where red is rrrrr, blue is bbbbb, and green is GGggg.
	ie. it's like this but little-endian:
		0bbb bbgg gggr rrrr
	Values are not linear to brightness of each color.
	Maps to standard RGB32 as follows:
		r = (13r + 2g + b)/2
		g = 6g + 2b
		b = (3r + 2g + 11b)/2
	ie. a value of (31, 0, 0) is actually color #c9002e.

rom texture data:
	List of textures, 16 bytes each.
	textures are referred to by their bank and address within each bank,
	called the *texture rom bank* and *texture rom address*.
	textures are as per normal gameboy texture format, ie:
		Each row of 8 pixels is defined by two bytes.
		The first byte defines the lower bits of the pixel values,
		and the second byte defines the upper bits.
		eg. 01010101 00110011 maps to pixel values 01230123

vram texture data:
	This is standard GB stuff. There are two banks of 256 textures each.
	These textures are indexed by both bank and index.
	These are known as *texture vram bank* and *texture vram index*
	and are 1-byte values each.
	The format is the same as rom texture data.

palette change data:
	A list of palette change lists. Each palette change list is 512b long
	and corresponds to the same index into the frame data list - ie. index 0 corresponds
	to frame index 0.
	Each palette change list contains 144 entries, corresponding to each line of pixels on screen.
		Before rendering that line, it writes the given palette group to palette numbers 0-3.
		Each palette change is specified as:
			The palette group address of the palette group to use, little-endian.
			The palette group bank of the palette group to use.

frame data:
	List of frames, 2048 bytes each.
	Frames are referred to by their index into this list.
	This is called the *frame index*.
	Each frame consists of:
		Tile data:
			19 rows of texture vram indexes:
				Each row consists of 21 texture vram indexes,
				followed by 11 bytes of padding.
			19 rows of tile flag values:
				Each row consists of 21 tile flag values,
				followed by 11 bytes of padding.
				Tile flag are one byte:
					0vh0bppp
					where v and h are flags saying if the tile should be vertically or horizontally flipped,
					b is the texture vram bank of the tile to display,
					and ppp is the color palette number to use.
		1 palette change, for the whole frame:
			This sets the value of palettes 4-7 for the frame.
			It is a palette group index that refers to the 4 new palette values to write.
		1 byte of scroll values:
			0yyy0xxx
			where yyy is scroll y value, and xxx is scroll x value.
			This allows you to scroll up to just under one tile in either axis, exposing the
			19th row or 21st column.
		One byte indicating length of the following load order list, between 0 and 25.
		List of load orders:
			A load order happens before the frame and indicates what textures should be loaded into
			VRAM. It consists of two parts:
				The source bank:
					The texture rom bank to copy from.
				The source address:
					The texture rom address of the first texture to copy.
				The destination bank:
					Either 0 or 1, the texture vram bank to load the textures into
				The destination index:
					The texture vram index of the first index to copy into
				Length:
					How many textures to copy. Up to 128.
			So, for example, if you wanted to copy textures 5-19 from ROM bank 2 into VRAM bank 0 indexes 30-44,
			and textures 20-21 from ROM bank 3 into VRAM bank 1 indexes 254-255, you would do this:
				2 (two load orders to do)
				2, $40, $50 (first source starts at bank 2, addr $4000 + 5 * 16 bytes = $4050)
				0, 30 (dest bank 0, index starts at 30)
				15 (fifteen textures to copy)
				1, $42, 0 (second source starts at bank 3, addr $4000 + 20 * 16 bytes = $4200)
				1, 254 (dest bank 1, index starts at 254)
				2 (two textures to copy)
			NOTE: There is a timing limit here based on both the number of load orders and
			the number of textures. The total number of textures + the number of load orders must be <= 51.
			For example, you can do 50 textures in one load order,
			or 49 spread over two, or 48 spread over three, etc,
			down to 25 load orders of 1 texture each.
		The remaining bytes up to 2048 are unused padding
			You can calculate how many bytes to use as: 888 - <number of load orders> * 6

frame order list:
	A list of frame indexes, indicating the order in which they should be played.
	Each index is displayed for one frame (1/59.7275th of a second).
	Frame indexes are encoded as:
		bbbbbbbb 01aaa000
	where the actual index is:
		00000bbb bbbbbaaa
	What this is actually doing, because there are 8 frames to a bank, is storing the frame
	as (bank, address upper byte).

Bank locations:
	Audio data, palette change list and palette groups must be in *high banks* 256-511.
	Everything else must be in *low banks* 1-255.
	Bank 0 is reserved for code.
